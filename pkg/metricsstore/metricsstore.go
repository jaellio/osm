// Package metricsstore implements a Prometheus metrics store for OSM's control plane metrics.
package metricsstore

import (
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/rs/zerolog/log"
)

// metricsRootNamespace is the root namespace for all the metrics emitted.
// Ex: osm_<metric-name>
const metricsRootNamespace = "osm"

// MetricsStore is a type that provides functionality related to metrics
type MetricsStore struct {
	// Define metrics by their category below ----------------------

	/*
	 * K8s metrics
	 */
	// K8sAPIEventCounter is the metric counter for the number of K8s API events
	K8sAPIEventCounter *prometheus.CounterVec

	/*
	 * Mesh resource metrics
	 */
	// NamespaceCount is the metric for the total number of Namespaces in the mesh
	NamespaceCount prometheus.GaugeFunc

	// ServiceCount is the metric for the total number of Services in the mesh
	ServiceCount prometheus.GaugeFunc

	// PodCount is the metric for the total number of Pods in the mesh
	PodCount prometheus.GaugeFunc

	// TrafficTargetCount is the metric for the total number of TrafficTargets in the mesh
	TrafficTargetCount prometheus.GaugeFunc

	// TrafficSplitCount is the metric for the total number of TrafficSplits in the mesh
	TrafficSplitCount prometheus.GaugeFunc

	// HTTPRouteGroupCount is the metric for the total number of HTTPRouteGroups in the mesh
	HTTPRouteGroupCount prometheus.GaugeFunc

	// TCPRouteCount is the metric for the total number of TCPRoutes in the mesh
	TCPRouteCount prometheus.GaugeFunc

	/*
	 * Proxy metrics
	 */
	// ProxyConnectCount is the metric for the total number of proxies connected to the controller
	ProxyConnectCount prometheus.Gauge

	// ProxyReconnectCount is the metric for the total reconnects from known proxies to the controller
	ProxyReconnectCount prometheus.Counter

	// ProxyConfigUpdateTime is the histogram to track time spent for proxy configuration and its occurrences
	ProxyConfigUpdateTime *prometheus.HistogramVec

	// ProxyBroadcastEventCounter is the metric for the total number of ProxyBroadcast events published
	ProxyBroadcastEventCount prometheus.Counter

	/*
	 * Injector metrics
	 */
	// InjectorSidecarCount counts the number of injector webhooks dealt with over time
	InjectorSidecarCount prometheus.Counter

	// InjectorRqTime the histogram to track times for the injector webhook calls
	InjectorRqTime *prometheus.HistogramVec

	/*
	 * Certificate metrics
	 */
	// CertIssuedCount is the metric counter for the number of certificates issued
	CertIssuedCount prometheus.Counter

	// CertXdsIssuedCounter the histogram to track the time to issue a certificates
	CertIssuedTime *prometheus.HistogramVec

	/*
	 * ErrCode metrics
	 */
	// ErrCodeCounter is the metric counter for the number of errcodes generated by OSM
	ErrCodeCounter *prometheus.CounterVec

	/*
	 * MetricsStore internals should be defined below --------------
	 */
	registry *prometheus.Registry
}

var defaultMetricsStore MetricsStore

// DefaultMetricsStore is the default metrics store
var DefaultMetricsStore = &defaultMetricsStore

func InitializeMetricStore(kube KubeResource, smi smiSpecs.MeshSpec) {
	/*
	 * K8s metrics
	 */
	defaultMetricsStore.K8sAPIEventCounter = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "k8s",
			Name:      "api_event_count",
			Help:      "Represents the number of events received from the Kubernetes API Server",
		},
		[]string{"type", "namespace"},
	)

	/*
	 * Mesh resource metrics
	 */
	defaultMetricsStore.NamespaceCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "namespace_count",
			Help:      "Represents the number of Namespaces monitored by OSM",
		}, func() float64 {
			meshNamespaces, err := kube.ListMonitoredNamespaces()
			if err != nil {
				log.Error().Err(err).Msgf("failed to list monitored namespaces")
			}
			return float64(len(meshNamespaces))
		})

	defaultMetricsStore.ServiceCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "service_count",
			Help:      "Represents the number of Services in the mesh",
		}, func() float64 {
			meshServices := kube.ListServices()
			return float64(len(meshServices))
		})

	defaultMetricsStore.PodCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "pod_count",
			Help:      "Represents the number of Pods monitored by OSM",
		}, func() float64 {
			meshPods := kube.ListPods()
			return float64(len(meshPods))
		})

	defaultMetricsStore.TrafficTargetCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "traffic_target_count",
			Help:      "Represents the number of TrafficTargets in the mesh",
		}, func() float64 {
			trafficTargets := smi.ListTrafficTargets()
			return float64(len(trafficTargets))
		})

	defaultMetricsStore.TrafficSplitCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "traffic_split_count",
			Help:      "Represents the number of TrafficSplits in the mesh",
		}, func() float64 {
			trafficSplits := smi.ListTrafficSplits()
			return float64(len(trafficSplits))
		})

	defaultMetricsStore.HTTPRouteGroupCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "http_route_group_count",
			Help:      "Represents the number of HTTPRouteGroups in the mesh",
		}, func() float64 {
			httpRouteGroups := smi.ListHTTPTrafficSpecs()
			return float64(len(httpRouteGroups))
		})

	defaultMetricsStore.TCPRouteCount = prometheus.NewGaugeFunc(
		prometheus.GaugeOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "resource",
			Name:      "tcp_route_count",
			Help:      "Represents the number of TCPRoutes in the mesh",
		}, func() float64 {
			tcpRoutes := smi.ListTCPTrafficSpecs()
			return float64(len(tcpRoutes))
		})

	/*
	 * Proxy metrics
	 */
	defaultMetricsStore.ProxyConnectCount = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: metricsRootNamespace,
		Subsystem: "proxy",
		Name:      "connect_count",
		Help:      "Represents the number of proxies connected to OSM controller",
	})

	defaultMetricsStore.ProxyReconnectCount = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: metricsRootNamespace,
		Subsystem: "proxy",
		Name:      "reconnect_count",
		Help:      "Represents the number of reconnects from known proxies to OSM controller",
	})

	defaultMetricsStore.ProxyConfigUpdateTime = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "proxy",
			Name:      "config_update_time",
			Buckets:   []float64{.1, .25, .5, 1, 2.5, 5, 10, 20, 40, 90},
			Help:      "Histogram to track time spent for proxy configuration",
		},
		[]string{
			"resource_type", // identifies a typeURI resource
			"success",       // further labels if the operation succeeded or not
		})

	defaultMetricsStore.ProxyBroadcastEventCount = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: metricsRootNamespace,
		Subsystem: "proxy",
		Name:      "broadcast_event_count",
		Help:      "Represents the number of ProxyBroadcast events published by the OSM controller",
	})

	/*
	 * Injector metrics
	 */
	defaultMetricsStore.InjectorSidecarCount = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: metricsRootNamespace,
		Subsystem: "injector",
		Name:      "injector_sidecar_count",
		Help:      "Counts the number of injector webhooks dealt with over time",
	})

	defaultMetricsStore.InjectorRqTime = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "injector",
			Name:      "injector_rq_time",
			Buckets:   []float64{.1, .25, .5, 1, 2.5, 5, 10, 20, 40},
			Help:      "Histogram for time taken to perform sidecar injection",
		},
		[]string{
			"success",
		})

	/*
	 * Certificate metrics
	 */
	defaultMetricsStore.CertIssuedCount = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: metricsRootNamespace,
		Subsystem: "cert",
		Name:      "issued_count",
		Help:      "Represents the total number of XDS certificates issued to proxies",
	})

	defaultMetricsStore.CertIssuedTime = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "cert",
			Name:      "issued_time",
			Buckets:   []float64{.1, .25, .5, 1, 2.5, 5, 10, 20, 40, 90},
			Help:      "Histogram to track time spent to issue xds certificate",
		},
		[]string{})

	/*
	 * ErrCode metrics
	 */
	defaultMetricsStore.ErrCodeCounter = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: metricsRootNamespace,
			Subsystem: "error",
			Name:      "err_code_count",
			Help:      "Respesents the number of errcodes generated by OSM",
		},
		[]string{"err_code"},
	)
	defaultMetricsStore.registry = prometheus.NewRegistry()
}

// Start store
func (ms *MetricsStore) Start(cs ...prometheus.Collector) {
	ms.registry.MustRegister(cs...)
}

// Stop store
func (ms *MetricsStore) Stop(cs ...prometheus.Collector) {
	for _, c := range cs {
		ms.registry.Unregister(c)
	}
}

// Handler return the registry
func (ms *MetricsStore) Handler() http.Handler {
	return promhttp.InstrumentMetricHandler(
		ms.registry,
		promhttp.HandlerFor(ms.registry, promhttp.HandlerOpts{}),
	)
}
